[{"path":"/articles/Differential_Methylation.html","id":"reading-in-our-input-file","dir":"Articles","previous_headings":"","what":"Reading in our input file","title":"Differential Methylation with PCBS","text":"provide script, Bismark2Matrix.R, can used covert Bismark outputed .cov files format.","code":"eigen <- read.delim(\"WGBS.txt\") # https://github.com/katlande/PCBS/WGBS.txt eigen[1:5,1:5] #>          cpgID trt1_PercMeth trt1_nCpG trt2_PercMeth trt2_nCpG #> 1 chr2:2505718     0.5581395        43     0.4084507        71 #> 2 chr2:1807326     0.5652174        69     0.4883721        43 #> 3 chr2:2490208     0.4489796        49     0.5416667        72 #> 4 chr2:5512828     0.5263158        38     0.6315789        19 #> 5 chr3:1296629     0.6000000        35     0.4242424        66"},{"path":[]},{"path":"/articles/Differential_Methylation.html","id":"defining-our-best-principle-component","dir":"Articles","previous_headings":"","what":"Defining our best principle component","title":"Differential Methylation with PCBS","text":"identify principle component (PC) best defines difference treatment control. multiple PCs delineate conditions, PC contributing variance chosen.","code":"DefineBestPC(eigen, IDs = c(\"trt\", \"ctl\")) # IDs segregate two conditions based on a common identifier in the column names of the eigen dataframe, rather than by column number. You may have to rename the columns of your input object if no common name exists. #>  #> Best PC to use is PC1 with a sample distance of 45.4, representing 29.81% of the total variance."},{"path":"/articles/Differential_Methylation.html","id":"score-each-cpg-by-its-eigenvector-value","dir":"Articles","previous_headings":"","what":"Score each CpG by its eigenvector value","title":"Differential Methylation with PCBS","text":"PC1 defined best PC, set PC=1 first condition IDs=c() option always treated treatment. Positive eigenvector scores (PC_Score) mean increased methylation treatment condition (hypermethylation), whereas negative eigenvector scores indicate decreased methylation treatment condition (hypomethylation).","code":"getPCRanks(eigen, IDs = c(\"trt\", \"ctl\"), PC = 1) -> ranks # Get an eigenvector score for each CpG based on principle component 1 head(ranks) #>                   PC_Score #> chr2:2505718  3.781088e-05 #> chr2:1807326  4.573342e-04 #> chr2:2490208  3.156102e-03 #> chr2:5512828 -5.695585e-03 #> chr3:1296629  2.822282e-03 #> chr3:3212276 -6.044066e-03"},{"path":"/articles/Differential_Methylation.html","id":"identifying-a-dml-cut-off","dir":"Articles","previous_headings":"","what":"Identifying a DML cut-off","title":"Differential Methylation with PCBS","text":"Eigenvector analysis assign p-values individual CpGs. However, test datasets, score-based cut-offs show comparable ability define true DMLs tools assign p-values. offer functionality define cut-score differential vs. non-differential DMLs, though note type analysis primary function eigenvector analysis.  Generally speaking, best cut-rank occurs just inflection point plot Absolute Rank vs. Absolute Score. cut-can estimated manually plot, rankDist() function can used estimate cutoff . rankDist() offers two modes. “intersect” method defines cut-intersection linear line best fit highest scoring CpGs (true variation), lowest scoring CpGs (background noise). Alternatively, “strict” method defines cut-simply half distance maximum rank used define line best fit highest scoring CpGs value produced intersect mode. high variability test genomes, PC-strict PC-intersect perform comparably softwares. low-variability test genomes, PC-strict greatly preforms PC-intersct well tested softwares false positive reduction, though comes cost slight increase false negative calls. Generally, PC-Strict better comparisons expected number true DMLs relatively low. Please note simply estimations. predicted cut-returned much higher much lower inflection point demonstrated figure , recommended select cut-rank manually. now file significance CpGs.","code":"rankDist(ranks, mode=\"intersect\") # Two modes \"intersect\" and \"strict\" #> Estimated rank cut-off for significant CpGs is 980. DMLs <- addRanks(ranks) # add rank order to our CpGs DMLs$significant <- DMLs$abs.order <= 980 # significant CpG cut-off defined by rankDist() is: 980 head(DMLs) #>                 PC_Score order abs.order  chr     pos significant #> chr3:3291453  0.03364091     1         1 chr3 3291453        TRUE #> chr3:31670    0.03343012     2         2 chr3   31670        TRUE #> chr3:3082482  0.03337153     3         3 chr3 3082482        TRUE #> chr2:350483  -0.03296202 50000         4 chr2  350483        TRUE #> chr1:8652017  0.03291018     4         5 chr1 8652017        TRUE #> chr3:4531184 -0.03270712 49999         6 chr3 4531184        TRUE"},{"path":"/articles/Differential_Methylation.html","id":"identifying-a-dml-cut-off-manually","dir":"Articles","previous_headings":"","what":"Identifying a DML cut-off manually","title":"Differential Methylation with PCBS","text":"cases, cut-predicted getPCRanks may look imperfect. cases, cut-values can tested manually:","code":"test_50 <- checkRank(ranks, 50) # set cut-off to 50 test_500 <- checkRank(ranks, 500) # set cut-off to 500 test_5000 <- checkRank(ranks, 5000) # set cut-off to 5000 gridExtra::grid.arrange(test_50+tilt(), test_500+tilt(), test_5000+tilt(), nrow=1)"},{"path":"/articles/Differential_Methylation.html","id":"calling-dmrs","dir":"Articles","previous_headings":"","what":"Calling DMRs","title":"Differential Methylation with PCBS","text":"Differentially methylated region (DMR) calling eigenvector analysis shines. simulated genomes, eigenvector-based DMR calling system lowest false call rate compared tested softwares (false positive + false negative). Basepair basepair, DMR callers dramatically predict size DMR regions compared present method. DMR calling algorithm works defining rank cut-, wherein CpGs rank extracted seeds. Nearby CpGs collapsed single seed points median. function expands outwards seed point maximum DMR size, identifies smallest expansion containing 90% variable CpGs","code":""},{"path":"/articles/Differential_Methylation.html","id":"dmr-calling-occurs-in-two-steps","dir":"Articles","previous_headings":"Calling DMRs","what":"DMR calling occurs in two steps:","title":"Differential Methylation with PCBS","text":"","code":"find_best_nSeed(ranks, 980) # (1) identifying the optimal number of seeds to use  #>  #> Checking 13 seed values for best DMR calling............. done! # Since no over-compression is detected, we can simply use the largest seed value tested - 2940 (980 x 3) DMRs <- Get_Novel_DMRs(ranks, 2940, DMR_resolution=200, minCpGs=10) # (2) call DMRs based on the optimal seed number #>  #> Trimming 135 DMRs... done! head(DMRs[order(DMRs$FDR, decreasing = F),]) #>      Chr   Start     End DMR_Zscore nCpGs            p DMR_size          FDR #> 114 chr3 4920450 4923267  -41.29788    24 8.005804e-08     2817 2.882090e-06 #> 97  chr3 4140014 4142951  -26.17133    25 1.081729e-07     2937 3.786051e-06 #> 93  chr3 1340221 1342791  -27.47889    23 1.236705e-07     2570 4.204797e-06 #> 57  chr1 8650728 8652017   64.51441    13 2.839677e-06     1289 9.370935e-05 #> 125 chr3 3960576 3962805   15.11025    14 6.495770e-06     2229 2.078646e-04 #> 78  chr3 5080015 5081519  -34.50625    10 1.812572e-05     1504 5.618972e-04"},{"path":"/articles/Differential_Methylation.html","id":"score-pre-defined-regions","dir":"Articles","previous_headings":"","what":"Score pre-defined regions","title":"Differential Methylation with PCBS","text":"Eigenvector scores allow users directly quantify methylation differences across pre-defined regions TSSs, enhancers, regions interest. offer functionality assess regions directly, rather querying novel DMR calls overlaps. getRegionScores returns mean eigenvector scores input region, well Z-score background, p-value. can see test set, true DMRs regions partially overlapping true DMRs significant, whereas random regions show enrichment.","code":"# Make a dataframe of regions to check: regions <- data.frame(chr=c(\"chr3\", \"chr3\", \"chr1\"),                       s=c(4920450, 3961576, 300000),                       e=c(4923267, 3963805, 302900),                       ID=c(\"Hypo-DMR\", \"partial Hyper-DMR\", \"random\"))  getRegionScores(DMLs, regions) #>             feature       meanPC nCpG          Z            p #> 1          Hypo-DMR -0.020963435   24 -4.6426679 3.804721e-08 #> 2 partial Hyper-DMR  0.008092709    8  1.7904906 7.955714e-05 #> 3            random -0.003612135    8 -0.8010134 2.596066e-01"},{"path":"/articles/Differential_Methylation.html","id":"metagenes","dir":"Articles","previous_headings":"","what":"Metagenes","title":"Differential Methylation with PCBS","text":"also provide functionality generating metagenes set regions based PC Scores. figures, values 0 represent regions treatment group hypermethylated, values 0 represent hypomethylated regions.","code":""},{"path":"/articles/Differential_Methylation.html","id":"make-a-metagene-from-the-significant-hypermethylated-dmrs","dir":"Articles","previous_headings":"Metagenes","what":"Make a metagene from the significant hypermethylated DMRs:","title":"Differential Methylation with PCBS","text":"hypermethylated DMR regions broadly show highly positive PC-score across regions. expect hypermethylated regions.","code":"hyper_DMRs <- DMRs[DMRs$FDR <= 0.05 & DMRs$DMR_Zscore > 0,] # Select all significantly hypermethylated DMRs regions_hyper <- hyper_DMRs[c(1:3)] # select chrom, start, and end of all hyper DMRs score_metagene(ranks, regions_hyper)"},{"path":"/articles/Differential_Methylation.html","id":"plot-metagenes-of-multiple-regions-together","dir":"Articles","previous_headings":"Metagenes","what":"Plot metagenes of multiple regions together","title":"Differential Methylation with PCBS","text":"expected, hypo-DMRs show negative PC-score across regions.","code":"# Let's plot the metagene of the hyper-DMRs and hypo-DMRs together on the same plot..  hypo_DMRs <- DMRs[DMRs$FDR <= 0.05 & DMRs$DMR_Zscore < 0,] # Select all significantly hypermethylated DMRs regions_hypo <- hypo_DMRs[c(1:3)] # select chrom, start, and end of all hyper DMRs  # Setting return.data = T will cause score_metagene to return raw data instead of a plot hyper_metagene <- score_metagene(ranks, regions_hyper, return.data = T) hypo_metagene <- score_metagene(ranks, regions_hypo, return.data = T)  # The multiple_metagenes function plots multiple metagenes using a list of raw data objects from score_metagene(). multiple_metagenes(data_list = list(hyper_metagene, hypo_metagene), # list of raw data                    set_names = c(\"Hyper DMRs\", \"Hypo DMRs\"), # names for elements of the data_list list                    title=\"Metagenes of DMR Regions\", legend.title = F)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kathryn Lande. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lande K (2024). PCBS: Principle Component BiSulfite. R package version 0.1.0, https://github.com/katlande/PCBS.","code":"@Manual{,   title = {PCBS: Principle Component BiSulfite},   author = {Kathryn Lande},   year = {2024},   note = {R package version 0.1.0},   url = {https://github.com/katlande/PCBS}, }"},{"path":[]},{"path":"/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Principle Component BiSulfite","text":"PCBS R package following dependencies: * tibble * ggrepel * ggplot2 * dplyr","code":""},{"path":"/index.html","id":"data-setup","dir":"","previous_headings":"","what":"Data Setup","title":"Principle Component BiSulfite","text":"PCBS tool analyzing WGBS datasets fast, flexible, accurate fashion. PCBS designed pipe Bismark-aligned WGBS data. PCBS input file can generated bismark .cov files provided Bismark2Matrix.R script. Usage: Rscript –vanilla Bismark2Matrix.R file_path file_tsv file_out * file_path = /path//cov/files * file_tsv = three column, tab-separated file format: * filename | sample | group * sam1.cov | s1_trt | trt * sam2.cov | s2_ctl | ctl file_out = output file name","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Principle Component BiSulfite","text":"devtools::install_github(“katlande/PCBS”)","code":""},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Principle Component BiSulfite","text":"See vignette","code":""},{"path":"/reference/DefineBestPC.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify your best principle component. — DefineBestPC","title":"Identify your best principle component. — DefineBestPC","text":"Defines best principle component use downstream analysis.","code":""},{"path":"/reference/DefineBestPC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify your best principle component. — DefineBestPC","text":"","code":"DefineBestPC(mat, IDs, filter_thresh, return.plot)"},{"path":"/reference/DefineBestPC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify your best principle component. — DefineBestPC","text":"mat Bismark2Matrix.R output file, data frame object IDs character vector IDs containing common names compared conditions. E.g., samples trt1, trt2 vs. ctl1, ctl2, IDs=c(\"trt\", \"ctl\") filter_thresh coverage threshold filtering, CpG coverage samples must larger value return.plot T/F, whether return PCA plot numeric representing best principle component downstream analysis","code":""},{"path":"/reference/Get_Novel_DMRs.html","id":null,"dir":"Reference","previous_headings":"","what":"Call DMRs from WGBS data. — Get_Novel_DMRs","title":"Call DMRs from WGBS data. — Get_Novel_DMRs","text":"DMR Calling.","code":""},{"path":"/reference/Get_Novel_DMRs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call DMRs from WGBS data. — Get_Novel_DMRs","text":"","code":"Get_Novel_DMRs(ranks, nSeeds, chromDictObj, DMR_resolution, QueryLimit, minCpGs, minZ, perms)"},{"path":"/reference/Get_Novel_DMRs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call DMRs from WGBS data. — Get_Novel_DMRs","text":"ranks Rank data frame getPCRanks. nSeeds Integer, number input seeds DMR expansion. chromDictObj chromDict() output. null, chromDict() run internally. DMR_resolution Automatic=NULL. Integer, number bases increase DMR expansion. NULL, QueryLimit/15. QueryLimit Automatic=5000. Maximum DMR expansion size (bp) minCpGs Minimum CpGs DMR region, regions fewer CpGs discarded. minZ Automatic=1. Absolute Z score threshold DMR calling; internal value. recommended play setting. perms Automatic=1000. Number permutations use defining null distribution. Increasing value largely influences computational time minimal return","code":""},{"path":"/reference/addRanks.html","id":null,"dir":"Reference","previous_headings":"","what":"Add ranks to eigenvector scores. — addRanks","title":"Add ranks to eigenvector scores. — addRanks","text":"Defines best principle component use downstream analysis.","code":""},{"path":"/reference/addRanks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add ranks to eigenvector scores. — addRanks","text":"","code":"getPCRanks(ranks)"},{"path":"/reference/addRanks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add ranks to eigenvector scores. — addRanks","text":"ranks getPCRanks output data frame.","code":""},{"path":"/reference/checkRank.html","id":null,"dir":"Reference","previous_headings":"","what":"Check k-values manually. — checkRank","title":"Check k-values manually. — checkRank","text":"Plots score vs. rank plot manually chosen rank cut-manual k selection.","code":""},{"path":"/reference/checkRank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check k-values manually. — checkRank","text":"","code":"checkRank(ranks, cutoff)"},{"path":"/reference/checkRank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check k-values manually. — checkRank","text":"ranks getPCRanks output data frame cutoff integer, rank value check","code":""},{"path":"/reference/chromDict.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a rank object into a chromDict. — chromDict","title":"Convert a rank object into a chromDict. — chromDict","text":"Internal many functions; creates chromDict faster computing times. chromDict can run separately speed functions run iteratively.","code":""},{"path":"/reference/chromDict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a rank object into a chromDict. — chromDict","text":"","code":"chromDict(mat)"},{"path":"/reference/chromDict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a rank object into a chromDict. — chromDict","text":"ranks getPCRanks output data frame","code":""},{"path":"/reference/find_best_nSeed.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify the seed number to use for DMR calling. — find_best_nSeed","title":"Identify the seed number to use for DMR calling. — find_best_nSeed","text":"Identifies optimal seed number use DMR calling.","code":""},{"path":"/reference/find_best_nSeed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify the seed number to use for DMR calling. — find_best_nSeed","text":"","code":"find_best_nSeed(ranks, CpG_cutoff, values, max.dmr.size, return.plot)"},{"path":"/reference/find_best_nSeed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify the seed number to use for DMR calling. — find_best_nSeed","text":"ranks Rank data frame getPCRanks. CpG_cutoff NULL numeric. NULL, seed numbers tested input values argument. numeric, seed numbers tested CpG_cutoff*values argument. Recommended us rankDist estimate null values Numeric vector, either seed numbers test CpG_cutoff=NULL multipliers CpG_cutoff numeric max.dmr.size Automatic=5000. Maximum DMR expansion size downstream analysis. Note: pipeline optimized 5000bp max DMR size, recommended play value. return.plot T/F, whether return plot numeric representing best seed number downstream analysis","code":""},{"path":"/reference/getRegionScores.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a metagene from PC Scores. — score_metagene","title":"Make a metagene from PC Scores. — score_metagene","text":"Returns p-values Z-scores CpGs set regions, compared local null background distribution.","code":""},{"path":"/reference/getRegionScores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a metagene from PC Scores. — score_metagene","text":"","code":"score_metagene(ranks, regions, bin, title, xaxis, yaxis, chromDictObj, return.data, linecol)"},{"path":"/reference/getRegionScores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a metagene from PC Scores. — score_metagene","text":"ranks getPCRanks output data.frame regions three-column dataframe containing set regions test. Columns = chrom, start, end. bin Number bins use metagenes. Default=100. title Output plot title xaxis Output plot x-axis title yaxis Output plot y-axis title chromDictObj Optional chromDictObject made chromDict(), runs internally set NULL (default). Scripts run function multiple times sped setting option return.data Whether return plot, data can run plot_metagene() multiple_metagenes(). linecol Line colour return.data=F, auto=\"red\"","code":""},{"path":"/reference/multiple_metagenes.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot multiple metagene data objects on a single plot. — multiple_metagenes","title":"Plot multiple metagene data objects on a single plot. — multiple_metagenes","text":"Plots multiple metagene object using raw data generated score_metagene().","code":""},{"path":"/reference/multiple_metagenes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot multiple metagene data objects on a single plot. — multiple_metagenes","text":"","code":"multiple_metagenes(data_list, set_names, title, xaxis, yaxis, legend.title, col, se_alpha)"},{"path":"/reference/multiple_metagenes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot multiple metagene data objects on a single plot. — multiple_metagenes","text":"data_list List score_metagene() raw data output set_names Character vector names score_metagene() object title Output plot title xaxis Output plot x-axis title yaxis Output plot y-axis title legend.title T/F, whether show legend title col Vector colours use lines se_alpha 0-1, alpha value standard error shading","code":""},{"path":"/reference/plot_metagene.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a metagene plot from raw metagene data. — plot_metagene","title":"Generate a metagene plot from raw metagene data. — plot_metagene","text":"Plots metagene object using raw data generated score_metagene().","code":""},{"path":"/reference/plot_metagene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a metagene plot from raw metagene data. — plot_metagene","text":"","code":"plot_metagene(data, title, xaxis, yaxis, linecol)"},{"path":"/reference/plot_metagene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a metagene plot from raw metagene data. — plot_metagene","text":"data list, score_metagene() raw data output title Output plot title xaxis Output plot x-axis title yaxis Output plot y-axis title linecol Colour line, auto=\"red\"","code":""},{"path":"/reference/rankDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify the best rank cut-off for significant CpGs. — rankDist","title":"Identify the best rank cut-off for significant CpGs. — rankDist","text":"Automated rank cut-estimator input CpGs.","code":""},{"path":"/reference/rankDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify the best rank cut-off for significant CpGs. — rankDist","text":"","code":"rankDist(ranks, draw_intersects, noise_perc, mode, return.plot)"},{"path":"/reference/rankDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify the best rank cut-off for significant CpGs. — rankDist","text":"ranks getPCRanks output data frame. draw_intersects T/F whether draw intersect lines return.plot=T noise_perc Automatic=0.5, numeric 0 1. Fraction ranks use model background noise. recommended play value. Increasing/decreasing returns looser/stricter threshold, respectively. mode \"intersect\" \"strict\", determine cut-\"intersect\" \"strict\" method. \"Strict\" recommended sets lower variability return.plot T/F, whether return plot numeric","code":""},{"path":"/reference/score_metagene.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a metagene from PC Scores. — score_metagene","title":"Make a metagene from PC Scores. — score_metagene","text":"Uses mean binned PC scores across set regions draw metagene.","code":""},{"path":"/reference/score_metagene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a metagene from PC Scores. — score_metagene","text":"","code":"score_metagene(ranks, regions, bin, title, xaxis, yaxis, chromDictObj, return.data, linecol)"},{"path":"/reference/score_metagene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a metagene from PC Scores. — score_metagene","text":"ranks getPCRanks output data.frame regions three-column data.frame containing set regions test. Columns = chrom, start, end. bin integer, number bins use metagenes. Default=100. title Output plot title xaxis Output plot x-axis title yaxis Output plot y-axis title chromDictObj Optional chromDictObject made chromDict(), runs internally set NULL (default). Scripts run function multiple times sped setting option. return.data T/F, whether return plot, data can run plot_metagene() multiple_metagenes(). linecol Colour line, auto=\"red\"","code":""},{"path":"/reference/se.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard error of a vector. — se","title":"Standard error of a vector. — se","text":"Takes standard error vector.","code":""},{"path":"/reference/se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard error of a vector. — se","text":"","code":"se(x)"}]
